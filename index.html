<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TANK BATTLE 3D</title>
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Michroma&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --green: #00ff88;
      --red: #ff2244;
      --blue: #00aaff;
      --dark: #030a05;
      --panel: rgba(0, 20, 10, 0.85);
    }

    body {
      background: var(--dark);
      color: var(--green);
      font-family: 'Michroma', sans-serif;
      overflow: hidden;
      height: 100vh;
      cursor: crosshair;
    }

    canvas#gameCanvas {
      display: block;
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
    }

    /* ===== LOBBY ===== */
    #lobby {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at center, #001a0a 0%, #000 100%);
      z-index: 1000;
    }

    .lobby-box {
      border: 2px solid var(--green);
      padding: 50px 60px;
      text-align: center;
      background: var(--panel);
      box-shadow: 0 0 60px rgba(0,255,136,0.3), inset 0 0 40px rgba(0,255,136,0.05);
      max-width: 500px;
      width: 90%;
    }

    .lobby-box h1 {
      font-family: 'Audiowide', cursive;
      font-size: 52px;
      color: var(--green);
      text-shadow: 0 0 30px var(--green);
      letter-spacing: 6px;
      margin-bottom: 8px;
    }

    .lobby-box .subtitle {
      color: #555;
      font-size: 13px;
      letter-spacing: 3px;
      margin-bottom: 40px;
    }

    .input-group {
      margin-bottom: 20px;
      text-align: left;
    }

    .input-group label {
      display: block;
      font-size: 11px;
      letter-spacing: 3px;
      color: #558866;
      margin-bottom: 8px;
    }

    .input-group input {
      width: 100%;
      padding: 14px 16px;
      background: rgba(0,255,136,0.07);
      border: 1px solid rgba(0,255,136,0.4);
      color: var(--green);
      font-family: 'Michroma', sans-serif;
      font-size: 16px;
      outline: none;
      transition: all 0.2s;
    }

    .input-group input:focus {
      border-color: var(--green);
      box-shadow: 0 0 15px rgba(0,255,136,0.3);
    }

    .input-group input::placeholder { color: #334; }

    .btn-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 30px;
    }

    .btn {
      padding: 16px;
      font-family: 'Audiowide', cursive;
      font-size: 14px;
      letter-spacing: 2px;
      border: 2px solid;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-host {
      background: var(--green);
      color: #000;
      border-color: var(--green);
    }

    .btn-host:hover {
      box-shadow: 0 0 25px var(--green);
      transform: translateY(-2px);
    }

    .btn-join {
      background: transparent;
      color: var(--green);
      border-color: var(--green);
    }

    .btn-join:hover {
      background: rgba(0,255,136,0.1);
      box-shadow: 0 0 25px rgba(0,255,136,0.3);
      transform: translateY(-2px);
    }

    #roomCodeDisplay {
      margin-top: 25px;
      padding: 18px;
      background: rgba(0,255,136,0.08);
      border: 1px dashed rgba(0,255,136,0.4);
      display: none;
    }

    #roomCodeDisplay .label { font-size: 11px; letter-spacing: 3px; color: #558866; }

    #roomCodeDisplay .code {
      font-family: 'Audiowide', cursive;
      font-size: 32px;
      letter-spacing: 8px;
      text-shadow: 0 0 15px var(--green);
      margin: 8px 0;
    }

    #roomCodeDisplay .hint { font-size: 11px; color: #445; }

    #statusMsg {
      margin-top: 15px;
      font-size: 13px;
      letter-spacing: 2px;
      color: #558866;
      min-height: 20px;
    }

    /* ===== HUD ===== */
    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
      display: none;
    }

    #hud.active { display: block; }

    /* Top center */
    #topHud {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    #topHud .game-title {
      font-family: 'Audiowide', cursive;
      font-size: 22px;
      letter-spacing: 6px;
      text-shadow: 0 0 15px var(--green);
    }

    #topHud .room-code {
      font-size: 11px;
      letter-spacing: 3px;
      color: #446655;
      margin-top: 4px;
    }

    /* Bottom health */
    #healthSection {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    #healthLabel {
      font-size: 10px;
      letter-spacing: 4px;
      color: #446655;
      margin-bottom: 6px;
    }

    #healthBarOuter {
      width: 280px;
      height: 18px;
      background: rgba(255,34,68,0.15);
      border: 1px solid rgba(255,34,68,0.5);
    }

    #healthBarInner {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--red), #ff8800);
      transition: width 0.3s;
      box-shadow: 0 0 10px var(--red);
    }

    /* Leaderboard */
    #leaderboard {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--panel);
      border: 1px solid rgba(0,255,136,0.3);
      padding: 16px 20px;
      min-width: 190px;
    }

    #leaderboard h3 {
      font-family: 'Audiowide', cursive;
      font-size: 12px;
      letter-spacing: 3px;
      margin-bottom: 12px;
      color: var(--green);
      border-bottom: 1px solid rgba(0,255,136,0.2);
      padding-bottom: 8px;
    }

    .lb-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      padding: 4px 0;
      color: #aaa;
    }

    .lb-row.me { color: var(--green); }

    .lb-row .lb-kills {
      font-family: 'Audiowide', cursive;
      color: var(--red);
    }

    /* Controls */
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: var(--panel);
      border: 1px solid rgba(0,255,136,0.2);
      padding: 14px 18px;
      font-size: 11px;
      letter-spacing: 1px;
      line-height: 2;
      color: #446655;
    }

    #controls span { color: var(--green); }

    /* Minimap */
    #minimap {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      background: rgba(0, 20, 10, 0.9);
      border: 2px solid var(--green);
      box-shadow: 0 0 20px rgba(0,255,136,0.3);
    }

    #minimap canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Stats top left */
    #myStats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: var(--panel);
      border: 1px solid rgba(0,255,136,0.3);
      padding: 16px 20px;
    }

    .stat-item { font-size: 13px; margin-bottom: 6px; color: #558866; }
    .stat-item span { font-family: 'Audiowide', cursive; color: var(--green); font-size: 18px; }

    /* Crosshair */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
    }

    #crosshair::before {
      content: '';
      position: absolute;
      top: 50%; left: 0; right: 0;
      height: 1px;
      background: rgba(0,255,136,0.8);
      box-shadow: 0 0 4px var(--green);
    }

    #crosshair::after {
      content: '';
      position: absolute;
      left: 50%; top: 0; bottom: 0;
      width: 1px;
      background: rgba(0,255,136,0.8);
      box-shadow: 0 0 4px var(--green);
    }

    /* Kill feed */
    #killFeed {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
    }

    .kill-msg {
      font-family: 'Audiowide', cursive;
      font-size: 28px;
      animation: killAnim 1.5s ease-out forwards;
      display: block;
    }

    @keyframes killAnim {
      0%   { opacity: 0; transform: scale(0.5) translateY(0); }
      30%  { opacity: 1; transform: scale(1.2) translateY(-10px); }
      100% { opacity: 0; transform: scale(1) translateY(-60px); }
    }

    /* Hit flash */
    #hitFlash {
      position: absolute;
      inset: 0;
      background: rgba(255,34,68,0.25);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s;
    }

    #hitFlash.flash { opacity: 1; }

    /* Respawn overlay */
    #respawnOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
    }

    #respawnOverlay.show { display: flex; }

    #respawnOverlay h2 {
      font-family: 'Audiowide', cursive;
      font-size: 48px;
      color: var(--red);
      text-shadow: 0 0 30px var(--red);
      margin-bottom: 20px;
    }

    #respawnTimer {
      font-family: 'Audiowide', cursive;
      font-size: 72px;
      color: var(--green);
      text-shadow: 0 0 30px var(--green);
    }
  </style>
</head>
<body>

<!-- LOBBY -->
<div id="lobby">
  <div class="lobby-box">
    <h1>TANK BATTLE</h1>
    <div class="subtitle">3D MULTIPLAYER COMBAT</div>

    <div class="input-group">
      <label>YOUR CALLSIGN</label>
      <input type="text" id="playerName" placeholder="e.g. Ghost, Viper, Tank01" maxlength="16">
    </div>

    <div class="btn-row">
      <button class="btn btn-host" onclick="hostGame()">HOST GAME</button>
      <button class="btn btn-join" onclick="showJoinInput()">JOIN GAME</button>
    </div>

    <div id="joinSection" style="display:none; margin-top:20px;">
      <div class="input-group">
        <label>ROOM CODE</label>
        <input type="text" id="roomCodeInput" placeholder="Paste code here" maxlength="30" style="letter-spacing:4px; text-transform:uppercase;">
      </div>
      <button class="btn btn-join" style="width:100%" onclick="joinGame()">CONNECT</button>
    </div>

    <div id="roomCodeDisplay">
      <div class="label">SHARE THIS CODE WITH FRIENDS</div>
      <div class="code" id="myRoomCode">...</div>
      <div class="hint">Waiting for players to join...</div>
    </div>

    <div id="statusMsg">Ready to battle</div>
  </div>
</div>

<!-- CANVAS -->
<canvas id="gameCanvas"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="topHud">
    <div class="game-title">TANK BATTLE</div>
    <div class="room-code" id="hudRoomCode"></div>
  </div>

  <div id="myStats">
    <div class="stat-item">KILLS <span id="myKills">0</span></div>
    <div class="stat-item">PLAYERS <span id="playerCount">1</span></div>
  </div>

  <div id="crosshair"></div>

  <div id="healthSection">
    <div id="healthLabel">HULL INTEGRITY</div>
    <div id="healthBarOuter">
      <div id="healthBarInner"></div>
    </div>
  </div>

  <div id="leaderboard">
    <h3>LEADERBOARD</h3>
    <div id="leaderboardList"></div>
  </div>

  <div id="controls">
    <span>W A S D</span> — Move<br>
    <span>MOUSE</span> — Aim<br>
    <span>CLICK</span> — Fire<br>
    <span>V</span> — Switch View<br>
    <span>SCROLL</span> — Zoom<br>
    <span>RIGHT DRAG</span> — Rotate<br>
  </div>

  <div id="minimap">
    <canvas id="minimapCanvas" width="200" height="200"></canvas>
  </div>

  <div id="killFeed"></div>
  <div id="hitFlash"></div>

  <div id="respawnOverlay">
    <h2>DESTROYED</h2>
    <div id="respawnTimer">3</div>
  </div>
</div>

<!-- PeerJS from CDN - free, no account needed -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// =============================================
// TANK BATTLE 3D - PeerJS Multiplayer
// Works on GitHub Pages - 100% Free
// =============================================

// --- GAME STATE ---
let peer = null;
let connections = [];      // host: all guest connections
let hostConn = null;       // guest: connection to host
let isHost = false;
let myId = null;
let myName = 'Tank';
let myHealth = 100;
let myKills = 0;
let isDead = false;
let lastShotTime = 0;

// Three.js
let scene, camera, renderer;
let tankMeshes = {};     // peerId -> THREE.Group
let bulletMeshes = {};   // bulletId -> THREE.Mesh
let myTank = null;

// Game data
let players = {};  // peerId -> { name, x, z, ry, ty, health, kills, color }
let bullets = {};  // bulletId -> { x, y, z, vx, vz, owner, id }

// Input
const keys = {};
let mouseX = 0, mouseY = 0;
let bulletCounter = 0;

// Camera controls
let cameraDistance = 18;
let cameraHeight = 12;
let cameraAngleOffset = 0; // rotation around tank
let isDraggingCamera = false;
let lastMouseX = 0;
let lastMouseY = 0;
let viewMode = 0; // 0 = behind, 1 = first-person, 2 = top-down, 3 = side

// Minimap
let minimapCtx = null;

// =============================================
// LOBBY FUNCTIONS
// =============================================

function setStatus(msg) {
  document.getElementById('statusMsg').textContent = msg;
}

function getMyName() {
  return document.getElementById('playerName').value.trim() || 'Tank_' + Math.floor(Math.random() * 999);
}

function randomColor() {
  const hues = [120, 180, 60, 270, 30, 200];
  const h = hues[Math.floor(Math.random() * hues.length)];
  return `hsl(${h}, 80%, 55%)`;
}

function makeShortCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return 'tankbattle-' + code; // prefix avoids collisions with random users
}

function displayCode(fullId) {
  // Show only the 4-letter part after 'tankbattle-'
  return fullId.replace('tankbattle-', '');
}

function hostGame() {
  myName = getMyName();
  isHost = true;
  setStatus('Creating room...');

  const roomId = makeShortCode();

  // Use custom short ID with PeerJS
  peer = new Peer(roomId, { debug: 0 });

  peer.on('open', (id) => {
    myId = id;
    const shortDisplay = displayCode(id);
    document.getElementById('myRoomCode').textContent = shortDisplay;
    document.getElementById('roomCodeDisplay').style.display = 'block';
    setStatus('Room ready! Waiting for players...');

    players[myId] = {
      name: myName,
      x: 0, z: 0, ry: 0, ty: 0,
      health: 100, kills: 0,
      color: randomColor()
    };

    startGame();
  });

  peer.on('connection', (conn) => {
    setupGuestConnection(conn);
  });

  peer.on('error', (err) => {
    // If ID taken, retry with new code
    if (err.type === 'unavailable-id') {
      peer.destroy();
      hostGame();
    } else {
      setStatus('Error: ' + err.message);
    }
  });
}

function showJoinInput() {
  document.getElementById('joinSection').style.display = 'block';
  document.getElementById('roomCodeInput').focus();
}

function joinGame() {
  myName = getMyName();
  isHost = false;
  const shortCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
  if (!shortCode) { setStatus('Please enter a room code!'); return; }

  // Re-attach the prefix the host used
  const fullCode = 'tankbattle-' + shortCode;

  setStatus('Connecting...');

  peer = new Peer({ debug: 0 });

  peer.on('open', (id) => {
    myId = id;
    hostConn = peer.connect(fullCode, { reliable: true });

    hostConn.on('open', () => {
      setStatus('Connected! Joining game...');
      // Send join info to host
      hostConn.send({ 
        type: 'join', 
        id: myId, 
        name: myName, 
        color: randomColor() 
      });
    });

    hostConn.on('data', (data) => {
      handleMessage(data, fullCode);
    });

    hostConn.on('close', () => {
      setStatus('Disconnected from host');
    });

    hostConn.on('error', (err) => {
      setStatus('Connection error: ' + err.message);
    });
  });

  peer.on('error', (err) => {
    setStatus('Wrong code or host offline. Check the code and try again!');
  });
}

// Host manages guest connections
function setupGuestConnection(conn) {
  connections.push(conn);

  conn.on('open', () => {
    console.log('Guest connection opened:', conn.peer);
  });

  conn.on('data', (data) => {
    if (data.type === 'join') {
      console.log('Guest joined:', data.id, data.name);

      // Add guest to players list
      players[data.id] = {
        name: data.name,
        x: (Math.random() - 0.5) * 60,
        z: (Math.random() - 0.5) * 60,
        ry: 0, ty: 0,
        health: 100, kills: 0,
        color: data.color
      };

      // Small delay so guest's data handler is fully ready
      setTimeout(() => {
        // Send full game state to guest
        conn.send({ 
          type: 'gameState', 
          players: players, 
          bullets: bullets 
        });

        // Tell all OTHER players about new guest
        relayToAll({ 
          type: 'playerJoined', 
          id: data.id, 
          player: players[data.id] 
        }, data.id);

        // Show on host's screen too
        createTankMesh(data.id, data.color);
        syncTankMesh(data.id);
        updateLeaderboard();
        updatePlayerCount();
      }, 300);

    } else {
      // Relay all other messages to everyone
      handleMessage(data, conn.peer);
      relayToAll(data, conn.peer);
    }
  });

  conn.on('close', () => {
    connections = connections.filter(c => c !== conn);
    delete players[conn.peer];
    removeTankMesh(conn.peer);
    broadcast({ type: 'playerLeft', id: conn.peer });
    updateLeaderboard();
    updatePlayerCount();
  });

  conn.on('error', (err) => {
    console.error('Connection error:', err);
  });
}

// =============================================
// MESSAGING
// =============================================

function broadcast(data, excludeId = null) {
  if (isHost) {
    connections.forEach(c => {
      if (c.peer !== excludeId && c.open) c.send(data);
    });
  } else if (hostConn && hostConn.open) {
    hostConn.send(data);
  }
}

function relayToAll(data, fromId) {
  if (!isHost) return;
  connections.forEach(c => {
    if (c.peer !== fromId && c.open) c.send(data);
  });
}

function handleMessage(data, fromId) {
  switch (data.type) {
    case 'gameState':
      // Full state received from host - start the game!
      players = data.players;
      bullets = data.bullets || {};
      // Don't create meshes here - startGame calls initThree first, THEN we create meshes
      startGame();
      break;

    case 'playerJoined':
      if (!players[data.id]) {
        players[data.id] = data.player;
        if (scene) { // only if Three.js is ready
          createTankMesh(data.id, data.player.color);
          syncTankMesh(data.id);
        }
        updateLeaderboard();
        updatePlayerCount();
      }
      break;

    case 'move':
      if (players[data.id]) {
        players[data.id].x = data.x;
        players[data.id].z = data.z;
        players[data.id].ry = data.ry;
        players[data.id].ty = data.ty;
        syncTankMesh(data.id);
      }
      break;

    case 'bullet':
      if (!bullets[data.bullet.id]) {
        bullets[data.bullet.id] = data.bullet;
        createBulletMesh(data.bullet);
      }
      break;

    case 'hit':
      if (data.targetId === myId) {
        myHealth = Math.max(0, myHealth - 25);
        updateHealthBar();
        flashHit();

        if (myHealth <= 0 && !isDead) {
          die(data.shooterName);
        }
      }
      if (players[data.targetId]) {
        players[data.targetId].health = Math.max(0, (players[data.targetId].health || 100) - 25);
      }
      break;

    case 'kill':
      if (data.killerId === myId) {
        myKills++;
        document.getElementById('myKills').textContent = myKills;
        showKillMsg('ENEMY DESTROYED!', '#00ff88');
      }
      if (players[data.killerId]) {
        players[data.killerId].kills = (players[data.killerId].kills || 0) + 1;
      }
      if (players[data.targetId]) {
        players[data.targetId].health = 100;
        players[data.targetId].x = (Math.random() - 0.5) * 60;
        players[data.targetId].z = (Math.random() - 0.5) * 60;
        syncTankMesh(data.targetId);
      }
      updateLeaderboard();
      break;

    case 'respawn':
      if (players[data.id]) {
        players[data.id].health = 100;
        players[data.id].x = data.x;
        players[data.id].z = data.z;
        syncTankMesh(data.id);
      }
      break;

    case 'playerLeft':
      delete players[data.id];
      removeTankMesh(data.id);
      updateLeaderboard();
      updatePlayerCount();
      break;
  }
}

// =============================================
// THREE.JS SETUP
// =============================================

function initThree() {
  const canvas = document.getElementById('gameCanvas');

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // Sky blue
  scene.fog = new THREE.FogExp2(0x87ceeb, 0.008); // Lighter blue fog

  camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 500);

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const sunLight = new THREE.DirectionalLight(0xffffcc, 1.2);
  sunLight.position.set(50, 80, 50);
  sunLight.castShadow = true;
  sunLight.shadow.camera.left = -60;
  sunLight.shadow.camera.right = 60;
  sunLight.shadow.camera.top = 60;
  sunLight.shadow.camera.bottom = -60;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.bias = -0.0001;
  scene.add(sunLight);

  // Add hemisphere light for better ambient
  const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x228b22, 0.4);
  scene.add(hemiLight);

  // Add some rim light
  const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
  rimLight.position.set(-50, 20, -50);
  scene.add(rimLight);

  // Ground - grass-like appearance
  const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
  const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x4a7c59,
    roughness: 0.9,
    metalness: 0.1
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Add grid overlay
  const gridHelper = new THREE.GridHelper(100, 40, 0x2d5a3d, 0x1a3d2a);
  gridHelper.position.y = 0.01;
  scene.add(gridHelper);

  // Border walls
  const wallMat = new THREE.MeshStandardMaterial({ 
    color: 0x8b4513,
    roughness: 0.8,
    metalness: 0.2
  });
  [
    [0, 2, -50, 100, 4, 2],
    [0, 2, 50, 100, 4, 2],
    [-50, 2, 0, 2, 4, 100],
    [50, 2, 0, 2, 4, 100]
  ].forEach(([x, y, z, w, h, d]) => {
    const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
    wall.position.set(x, y, z);
    wall.castShadow = true;
    wall.receiveShadow = true;
    scene.add(wall);
  });

  // Obstacles - rocks/barriers
  const obstacleMat = new THREE.MeshStandardMaterial({ 
    color: 0x696969,
    roughness: 0.9,
    metalness: 0.1
  });
  const obstaclePositions = [
    [15, 1.5, 15], [-15, 1.5, 15], [15, 1.5, -15], [-15, 1.5, -15],
    [0, 2, 25], [0, 2, -25], [25, 2, 0], [-25, 2, 0],
    [10, 1, 10], [-10, 1, -10], [20, 1.5, -20], [-20, 1.5, 20]
  ];
  obstaclePositions.forEach(([x, y, z]) => {
    const size = 2 + Math.random() * 2;
    const height = y * 2 + Math.random() * 1;
    const obs = new THREE.Mesh(
      new THREE.BoxGeometry(size, height, size),
      obstacleMat
    );
    obs.position.set(x, y, z);
    obs.rotation.y = Math.random() * Math.PI;
    obs.castShadow = true;
    obs.receiveShadow = true;
    scene.add(obs);
  });

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
}

function createTankMesh(id, color) {
  if (tankMeshes[id]) return;

  const g = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ 
    color, 
    metalness: 0.6,
    roughness: 0.4,
    emissive: color,
    emissiveIntensity: 0.1
  });

  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.9, 3.2), mat);
  body.castShadow = true;
  body.receiveShadow = true;
  g.add(body);

  // Tracks (sides)
  const trackMat = new THREE.MeshStandardMaterial({ 
    color: 0x222222, 
    roughness: 1,
    metalness: 0.3
  });
  [-1.2, 1.2].forEach(xOff => {
    const track = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 3.4), trackMat);
    track.position.set(xOff, -0.2, 0);
    track.castShadow = true;
    g.add(track);
  });

  // Turret group
  const turretGroup = new THREE.Group();
  turretGroup.position.y = 0.7;

  const turretMat = new THREE.MeshStandardMaterial({ 
    color, 
    metalness: 0.7,
    roughness: 0.3,
    emissive: color,
    emissiveIntensity: 0.15
  });
  
  const turret = new THREE.Mesh(
    new THREE.CylinderGeometry(0.55, 0.65, 0.7, 8),
    turretMat
  );
  turret.castShadow = true;
  turretGroup.add(turret);

  // Barrel
  const barrelMat = new THREE.MeshStandardMaterial({ 
    color: 0x333333, 
    metalness: 0.9, 
    roughness: 0.2
  });
  const barrel = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.18, 2.2, 8),
    barrelMat
  );
  barrel.rotation.z = Math.PI / 2;
  barrel.position.set(1.3, 0, 0);
  barrel.castShadow = true;
  turretGroup.add(barrel);

  g.add(turretGroup);
  g.userData.turretGroup = turretGroup;
  g.userData.playerId = id;

  g.position.y = 0.6;
  scene.add(g);
  tankMeshes[id] = g;
}

function syncTankMesh(id) {
  const p = players[id];
  const mesh = tankMeshes[id];
  if (!p || !mesh) return;

  mesh.position.x = p.x;
  mesh.position.z = p.z;
  mesh.rotation.y = p.ry || 0;
  if (mesh.userData.turretGroup) {
    mesh.userData.turretGroup.rotation.y = (p.ty || 0) - (p.ry || 0);
  }
}

function removeTankMesh(id) {
  if (tankMeshes[id]) {
    scene.remove(tankMeshes[id]);
    delete tankMeshes[id];
  }
}

function createBulletMesh(bullet) {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.22, 8, 8),
    new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 2 })
  );
  mesh.position.set(bullet.x, bullet.y, bullet.z);
  scene.add(mesh);
  bulletMeshes[bullet.id] = mesh;

  // Auto remove after 4s
  setTimeout(() => {
    if (bulletMeshes[bullet.id]) {
      scene.remove(bulletMeshes[bullet.id]);
      delete bulletMeshes[bullet.id];
    }
    delete bullets[bullet.id];
  }, 4000);
}

// =============================================
// GAME LOOP
// =============================================

let gameStarted = false;

function startGame() {
  if (gameStarted) return;
  gameStarted = true;

  console.log('startGame called, myId:', myId, 'isHost:', isHost);

  // Hide lobby, show HUD
  document.getElementById('lobby').style.display = 'none';
  document.getElementById('hud').classList.add('active');
  document.getElementById('hudRoomCode').textContent = 'ROOM: ' + (isHost ? displayCode(myId) : displayCode(hostConn.peer));

  // Init Three.js FIRST before creating any meshes
  initThree();

  // Make sure my own player data exists
  if (!players[myId]) {
    players[myId] = {
      name: myName,
      x: (Math.random() - 0.5) * 60,
      z: (Math.random() - 0.5) * 60,
      ry: 0, ty: 0,
      health: 100, kills: 0,
      color: randomColor()
    };
  }

  // NOW create all tank meshes (scene exists now)
  Object.keys(players).forEach(id => {
    createTankMesh(id, players[id].color);
    syncTankMesh(id);
  });

  myTank = tankMeshes[myId];
  console.log('My tank created:', myTank ? 'YES' : 'NO');
  console.log('Total players:', Object.keys(players).length);

  updateLeaderboard();
  updatePlayerCount();
  
  // Initialize minimap
  const minimapCanvas = document.getElementById('minimapCanvas');
  minimapCtx = minimapCanvas.getContext('2d');
  
  animate();
}

// =============================================
// MINIMAP
// =============================================

function renderMinimap() {
  if (!minimapCtx || !myTank) return;

  const ctx = minimapCtx;
  const size = 200;
  const mapSize = 100; // game world is -50 to 50
  const scale = size / mapSize;

  // Clear
  ctx.fillStyle = 'rgba(0, 10, 5, 0.8)';
  ctx.fillRect(0, 0, size, size);

  // Draw border
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, size - 2, size - 2);

  // Draw grid
  ctx.strokeStyle = 'rgba(0, 255, 136, 0.2)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const pos = (size / 4) * i;
    ctx.beginPath();
    ctx.moveTo(pos, 0);
    ctx.lineTo(pos, size);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, pos);
    ctx.lineTo(size, pos);
    ctx.stroke();
  }

  // Convert world coords to minimap coords
  function toMinimap(x, z) {
    return {
      x: (x + 50) * scale,
      y: (z + 50) * scale
    };
  }

  // Draw all players
  Object.keys(players).forEach(id => {
    const p = players[id];
    const pos = toMinimap(p.x, p.z);
    const isMe = id === myId;

    // Draw tank as triangle
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(p.ry);

    ctx.fillStyle = isMe ? '#00ff88' : p.color;
    ctx.beginPath();
    ctx.moveTo(0, -6);
    ctx.lineTo(-4, 4);
    ctx.lineTo(4, 4);
    ctx.closePath();
    ctx.fill();

    if (isMe) {
      // Add glow for player
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();

    // Draw name
    if (!isMe) {
      ctx.fillStyle = p.color;
      ctx.font = '9px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(p.name.substring(0, 8), pos.x, pos.y - 10);
    }
  });

  // Draw bullets
  Object.keys(bullets).forEach(bid => {
    const b = bullets[bid];
    const pos = toMinimap(b.x, b.z);
    
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
    ctx.fill();
  });

  // Draw "YOU" label
  const myPos = toMinimap(players[myId].x, players[myId].z);
  ctx.fillStyle = '#00ff88';
  ctx.font = 'bold 10px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('YOU', myPos.x, myPos.y + 16);
}

let lastBroadcast = 0;

function animate() {
  requestAnimationFrame(animate);

  if (!myTank || isDead) {
    renderer.render(scene, camera);
    return;
  }

  const p = players[myId];
  if (!p) return;

  const speed = 0.18;
  const rotSpeed = 0.045;
  let moved = false;

  if (keys['w'] || keys['arrowup'])    { p.x += Math.sin(p.ry) * speed; p.z += Math.cos(p.ry) * speed; moved = true; }
  if (keys['s'] || keys['arrowdown'])  { p.x -= Math.sin(p.ry) * speed; p.z -= Math.cos(p.ry) * speed; moved = true; }
  if (keys['a'] || keys['arrowleft'])  { p.ry += rotSpeed; moved = true; }
  if (keys['d'] || keys['arrowright']) { p.ry -= rotSpeed; moved = true; }

  // Clamp to arena
  p.x = Math.max(-48, Math.min(48, p.x));
  p.z = Math.max(-48, Math.min(48, p.z));

  // Turret aims precisely at mouse cursor position in 3D world
  const raycaster = new THREE.Raycaster();
  const mouseVector = new THREE.Vector2(mouseX, mouseY);
  raycaster.setFromCamera(mouseVector, camera);
  
  // Raycast to ground plane (y = 0)
  const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  const intersectPoint = new THREE.Vector3();
  const didIntersect = raycaster.ray.intersectPlane(groundPlane, intersectPoint);
  
  if (didIntersect) {
    // Calculate precise angle from tank position to mouse ground position
    const dx = intersectPoint.x - p.x;
    const dz = intersectPoint.z - p.z;
    p.ty = Math.atan2(dx, dz);
  } else {
    // Fallback if ray doesn't hit ground (looking at sky)
    p.ty = p.ry;
  }

  syncTankMesh(myId);

  // Camera follow with controls
  if (viewMode === 1) {
    // First-person view - camera inside turret
    const turretAngle = p.ty;
    camera.position.x = p.x + Math.sin(turretAngle) * 0.5;
    camera.position.y = 2.5; // Eye level
    camera.position.z = p.z + Math.cos(turretAngle) * 0.5;
    
    // Look in turret direction
    camera.lookAt(
      p.x + Math.sin(turretAngle) * 50,
      2,
      p.z + Math.cos(turretAngle) * 50
    );
  } else {
    // Third-person views
    const angleAroundTank = p.ry + cameraAngleOffset;
    camera.position.x = p.x - Math.sin(angleAroundTank) * cameraDistance;
    camera.position.y = cameraHeight;
    camera.position.z = p.z - Math.cos(angleAroundTank) * cameraDistance;
    camera.lookAt(p.x, 1, p.z);
  }

  // Move bullets
  Object.keys(bullets).forEach(bid => {
    const b = bullets[bid];
    b.x += b.vx;
    b.z += b.vz;
    if (bulletMeshes[bid]) {
      bulletMeshes[bid].position.set(b.x, b.y, b.z);
    }

    // Check hits on other tanks
    Object.keys(players).forEach(pid => {
      if (pid === b.owner || pid === myId) return;
      const tp = players[pid];
      const dx = b.x - tp.x, dz = b.z - tp.z;
      if (Math.sqrt(dx * dx + dz * dz) < 2.2) {
        broadcast({ type: 'hit', targetId: pid, shooterId: myId, shooterName: myName });
        if (bulletMeshes[bid]) { scene.remove(bulletMeshes[bid]); delete bulletMeshes[bid]; }
        delete bullets[bid];

        // Check kill
        const newHp = (players[pid].health || 100) - 25;
        if (newHp <= 0) {
          broadcast({ type: 'kill', killerId: myId, targetId: pid, killerName: myName });
          myKills++;
          document.getElementById('myKills').textContent = myKills;
          showKillMsg('ENEMY DESTROYED!', '#00ff88');
          if (players[myId]) players[myId].kills = myKills;
          updateLeaderboard();
        }
      }
    });

    // Check if MY tank is hit (by others' bullets)
    if (b.owner !== myId) {
      const dx = b.x - p.x, dz = b.z - p.z;
      if (Math.sqrt(dx * dx + dz * dz) < 2.2) {
        myHealth = Math.max(0, myHealth - 25);
        updateHealthBar();
        flashHit();
        if (bulletMeshes[bid]) { scene.remove(bulletMeshes[bid]); delete bulletMeshes[bid]; }
        delete bullets[bid];
        if (myHealth <= 0 && !isDead) die(b.ownerName || '???');
      }
    }
  });

  // Broadcast my position
  const now = Date.now();
  if (moved && now - lastBroadcast > 50) {
    lastBroadcast = now;
    broadcast({ type: 'move', id: myId, x: p.x, z: p.z, ry: p.ry, ty: p.ty });
  }

  // Render minimap
  renderMinimap();

  renderer.render(scene, camera);
}

// =============================================
// SHOOTING
// =============================================

document.addEventListener('click', () => {
  if (isDead || !myTank || !players[myId]) return;
  const now = Date.now();
  if (now - lastShotTime < 500) return; // 500ms cooldown
  lastShotTime = now;

  const p = players[myId];
  const angle = p.ty;
  const speed = 0.7;
  const bid = myId + '_' + (bulletCounter++);

  const bullet = {
    id: bid,
    owner: myId,
    ownerName: myName,
    x: p.x + Math.sin(angle) * 2.5,
    y: 1.2,
    z: p.z + Math.cos(angle) * 2.5,
    vx: Math.sin(angle) * speed,
    vz: Math.cos(angle) * speed
  };

  bullets[bid] = bullet;
  createBulletMesh(bullet);
  broadcast({ type: 'bullet', bullet });
});

// =============================================
// INPUT
// =============================================

document.addEventListener('keydown', e => { 
  keys[e.key.toLowerCase()] = true;
  
  // V key to switch view modes
  if (e.key.toLowerCase() === 'v') {
    viewMode = (viewMode + 1) % 4;
    if (viewMode === 0) { // Behind tank
      cameraDistance = 18;
      cameraHeight = 12;
      cameraAngleOffset = 0;
    } else if (viewMode === 1) { // First-person
      cameraDistance = 0;
      cameraHeight = 2;
      cameraAngleOffset = 0;
    } else if (viewMode === 2) { // Top-down
      cameraDistance = 5;
      cameraHeight = 35;
      cameraAngleOffset = 0;
    } else if (viewMode === 3) { // Side view
      cameraDistance = 22;
      cameraHeight = 10;
      cameraAngleOffset = Math.PI / 2;
    }
  }
});

document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

document.addEventListener('mousemove', e => {
  mouseX = (e.clientX / innerWidth)  * 2 - 1;
  mouseY = -(e.clientY / innerHeight) * 2 + 1;

  // Right-click drag to rotate camera
  if (isDraggingCamera) {
    const deltaX = e.clientX - lastMouseX;
    cameraAngleOffset += deltaX * 0.005;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }
});

// Right-click to drag camera
document.addEventListener('mousedown', e => {
  if (e.button === 2) { // Right click
    isDraggingCamera = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    e.preventDefault();
  }
});

document.addEventListener('mouseup', e => {
  if (e.button === 2) {
    isDraggingCamera = false;
  }
});

document.addEventListener('contextmenu', e => e.preventDefault()); // Disable right-click menu

// Mouse wheel to zoom
document.addEventListener('wheel', e => {
  e.preventDefault();
  cameraDistance += e.deltaY * 0.02;
  cameraDistance = Math.max(5, Math.min(40, cameraDistance)); // Clamp between 5 and 40
}, { passive: false });

// =============================================
// HUD HELPERS
// =============================================

function updateHealthBar() {
  document.getElementById('healthBarInner').style.width = myHealth + '%';
}

function flashHit() {
  const el = document.getElementById('hitFlash');
  el.classList.add('flash');
  setTimeout(() => el.classList.remove('flash'), 150);
}

function showKillMsg(msg, color) {
  const feed = document.getElementById('killFeed');
  const el = document.createElement('span');
  el.className = 'kill-msg';
  el.style.color = color;
  el.style.textShadow = `0 0 20px ${color}`;
  el.textContent = msg;
  feed.appendChild(el);
  setTimeout(() => feed.removeChild(el), 1500);
}

function die(killerName) {
  isDead = true;
  document.getElementById('respawnOverlay').classList.add('show');
  showKillMsg('YOU WERE DESTROYED!', '#ff2244');

  let count = 3;
  document.getElementById('respawnTimer').textContent = count;

  const interval = setInterval(() => {
    count--;
    document.getElementById('respawnTimer').textContent = count;
    if (count <= 0) {
      clearInterval(interval);
      respawn();
    }
  }, 1000);
}

function respawn() {
  isDead = false;
  myHealth = 100;
  updateHealthBar();
  document.getElementById('respawnOverlay').classList.remove('show');

  if (players[myId]) {
    players[myId].x = (Math.random() - 0.5) * 60;
    players[myId].z = (Math.random() - 0.5) * 60;
    players[myId].health = 100;
    syncTankMesh(myId);
    broadcast({ type: 'respawn', id: myId, x: players[myId].x, z: players[myId].z });
  }
}

function updateLeaderboard() {
  const sorted = Object.entries(players)
    .sort(([, a], [, b]) => (b.kills || 0) - (a.kills || 0))
    .slice(0, 6);

  document.getElementById('leaderboardList').innerHTML = sorted.map(([id, p], i) => `
    <div class="lb-row ${id === myId ? 'me' : ''}">
      <span>${i + 1}. ${p.name || 'Tank'}</span>
      <span class="lb-kills">${p.kills || 0}</span>
    </div>
  `).join('');
}

function updatePlayerCount() {
  document.getElementById('playerCount').textContent = Object.keys(players).length;
}
</script>
</body>
</html>
